<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chat Home</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha512-‚Ä¶hash‚Ä¶" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            display: flex;
            height: 100vh;
            font-family: 'Courier New', monospace;
            background: #f5f5f0;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background: #f5f5f0;
            padding: 20px;
            border-right: 4px solid #000;
            overflow-y: auto;
        }

        #sidebar h3 {
            font-size: 18px;
            font-weight: 900;
            text-transform: uppercase;
            margin: 0 0 15px 0;
            padding: 10px;
            background: #25d366;
            color: #fff;
            border: 3px solid #000;
            box-shadow: 4px 4px 0 #000;
        }

        #sidebar a {
            display: inline-block;
            padding: 8px 16px;
            background: #f5f5f0;
            color: #000;
            text-decoration: none;
            border: 3px solid #000;
            box-shadow: 3px 3px 0 #000;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.1s;
        }

        #sidebar a:hover {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0 #000;
        }

        #sidebar hr {
            border: none;
            border-top: 3px solid #000;
            margin: 20px 0;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 3px solid #000;
            background: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }

        input[type="text"]:focus {
            outline: none;
            background: #fffef0;
        }

        input[type="text"]:disabled {
            background: #e0e0d8;
            cursor: not-allowed;
        }

        button {
            padding: 12px 20px;
            background: #25d366;
            color: #fff;
            border: 3px solid #000;
            box-shadow: 4px 4px 0 #000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.1s;
        }

        button:hover:not(:disabled) {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }

        button:active:not(:disabled) {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #000;
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
        }

        #chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f5f5f0;
        }

        #chat-log {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #fff;
            border: 4px solid #000;
            margin: 20px;
            box-shadow: 8px 8px 0 #000;
        }

        #chat-log p {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f0;
            border: 3px solid #000;
            box-shadow: 3px 3px 0 #000;
        }

        #chat-log b {
            color: #25d366;
            font-weight: 900;
        }

        #chat-input-area {
            display: flex;
            padding: 20px;
            gap: 10px;
        }

        #chat-input-area input {
            flex: 1;
            margin-bottom: 0;
        }

        .chat-item, .user-item {
            padding: 12px;
            margin: 8px 0;
            background: #fff;
            cursor: pointer;
            border: 3px solid #000;
            box-shadow: 4px 4px 0 #000;
            font-weight: bold;
            transition: all 0.1s;
        }

        .chat-item:hover, .user-item:hover {
            background: #25d366;
            color: #fff;
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }

        .chat-item:active, .user-item:active {
            transform: translate(4px, 4px);
            box-shadow: 0 0 0 #000;
        }

        #search-results, #group-search-results {
            max-height: 200px;
            overflow-y: auto;
        }

        #group-selected-users {
            margin: 10px 0;
            padding: 10px;
            background: #fff;
            border: 3px solid #000;
            min-height: 50px;
        }

        #group-selected-users span {
            display: inline-block;
            margin: 4px;
            padding: 6px 12px;
            background: #25d366;
            color: #fff;
            border: 3px solid #000;
            box-shadow: 2px 2px 0 #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s;
        }

        #group-selected-users span:hover {
            background: #1ab553ff;
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0 #000;
        }

        #create-group-btn {
            width: 100%;
            margin-top: 10px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #f5f5f0;
            border: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #25d366;
            border: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #1ab553ff;
        }
        #typing-indicator {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .typing-animation {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .typing-animation span {
            width: 8px;
            height: 8px;
            background: #25d366;
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .typing-animation span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-animation span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
    </style>
</head>

<body>

    <!-- SIDEBAR -->
    <div id="sidebar">

        <h3>
            <i class="fa-solid fa-user"></i>
            {{ request.user.username }}
        </h3>
        <a href="{% url 'logout' %}" id="logout-link">Logout</a>

        <hr>

        <h3>
            <i class="fa-solid fa-magnifying-glass"></i>
            Search Users</h3>
        <input type="text" id="search-box" placeholder="Search...">
        <div id="search-results"></div>

        <hr>

        <h3>
            <i class="fa-solid fa-plus"></i>
            Create Group
        </h3>
        <input type="text" id="group-name" placeholder="Group Name">
        <input type="text" id="group-search-box" placeholder="Search users...">
        <div id="group-search-results"></div>
        <div id="group-selected-users"></div>
        <button id="create-group-btn">Create Group</button>

        <hr>

        <h3>
            <i class="fa-solid fa-comment"></i>
            My Chats</h3>
        <div id="chat-list"></div>

    </div>


    <!-- CHAT AREA -->
    <div id="chat-area">

        <div id="chat-log"></div>
        <div id="typing-indicator"
            style="
                font-weight: bold;
                padding: 8px 20px;
                display: none;
                color: #25d366;
             ">
               <span class="typing-username"></span>
                <div class="typing-animation">
                    <span></span><span></span><span></span>
                </div>
        </div>
        <div id="chat-input-area">
            <input type="text" id="chat-message-input" placeholder="Type a message..." disabled>
            <button id="chat-message-submit" disabled>Send</button>
        </div>

    </div>

    <script>
        let currentChatId = null;
        let chatSocket = null;
        const currentUserId = {{ request.user.id }};
        let chatKey = null;
        let myKeyPair = null;
        let myPublicKeyExported = null;
        let encryptionReady = false; // Track initialization state
        let typingTimeout = null;
        const TYPING_TIMER_LENGTH = 2000;
        let encryptionPassword = null; 

        // function to handle typing events
        function handleTyping() {
            if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) return;
            // send typing event to the server
             chatSocket.send(JSON.stringify({
                type: "typing"
            }));
        }

        document.getElementById('chat-message-input').addEventListener('input', function() {
            if (!this.value.trim()) return;
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            handleTyping();
            typingTimeout = setTimeout(() => {
            }, TYPING_TIMER_LENGTH);
        });

        // Derive encryption key from password using PBKDF2
        async function deriveKeyFromPassword(password, saltBuffer) {
            const enc = new TextEncoder();
            const passwordBuffer = enc.encode(password);

            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                passwordBuffer,
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            
            // Derive AES-GCM key from password
            return await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: saltBuffer,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        function clearPasswordFromSession() {
            sessionStorage.removeItem("encryptionPassword");
        }

        document.getElementById('logout-link').addEventListener('click', function(e) {
            e.preventDefault();
            clearPasswordFromSession();
            window.location.href = this.href;
        });


        // Encrypt private key with password
        async function encryptPrivateKeyWithPassword(privateKeyJwk, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const encryptionKey = await deriveKeyFromPassword(password, salt);
            
            const enc = new TextEncoder();
            const privateKeyString = JSON.stringify(privateKeyJwk);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encryptedData = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                encryptionKey,
                enc.encode(privateKeyString)
            );
            
            return {
                encryptedPrivateKey: arrayBufferToBase64(encryptedData),
                salt: arrayBufferToBase64(salt),
                iv: arrayBufferToBase64(iv)
            };
        }

        // Decrypt private key with password
        async function decryptPrivateKeyWithPassword(encryptedData, password) {
            const salt = base64ToArrayBuffer(encryptedData.salt);
            const iv = base64ToArrayBuffer(encryptedData.iv);
            const ciphertext = base64ToArrayBuffer(encryptedData.encryptedPrivateKey);
            
            const encryptionKey = await deriveKeyFromPassword(password, salt);
            
            try {
                const decryptedData = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    encryptionKey,
                    ciphertext
                );
                
                const dec = new TextDecoder();
                const privateKeyString = dec.decode(decryptedData);
                return JSON.parse(privateKeyString);
            } catch (error) {
                throw new Error('Invalid password or corrupted data');
            }
        }

        // Initialize encryption on page load
        async function initEncryption() {
            try {
                document.body.style.opacity = '0.5';
                document.body.style.pointerEvents = 'none';
                const savedPassword = sessionStorage.getItem("encryptionPassword");
                if (savedPassword) {
                    encryptionPassword = savedPassword;
                }
                
                // Check if keys exist on server
                const serverKeysResponse = await fetch('/api/get-my-encrypted-key/');
                
                if (serverKeysResponse.ok) {
                    // Keys exist on server - need password to decrypt
                    const serverKeys = await serverKeysResponse.json();
                    
                    // Check if we have password in memory (already unlocked this session)
                    if (encryptionPassword) {
                        await unlockKeysWithPassword(serverKeys, encryptionPassword);
                    } else {
                        // Show password prompt
                        showPasswordPrompt(serverKeys, 'unlock');
                        return; // Don't hide loading yet
                    }
                } else if (serverKeysResponse.status === 404) {
                    // No keys on server - need to create new ones
                    showPasswordPrompt(null, 'create');
                    return;
                } else {
                    throw new Error('Failed to check for existing keys');
                }
                
                encryptionReady = true;
                document.body.style.opacity = '1';
                document.body.style.pointerEvents = 'auto';
                
            } catch (error) {
                console.error('Encryption initialization error:', error);
                alert('Failed to initialize encryption. Please refresh the page.');
                document.body.style.opacity = '1';
                document.body.style.pointerEvents = 'auto';
            }
        }
       function showPasswordPrompt(serverKeys, mode) {
    // IMPORTANT: Re-enable interactions so modal works
    document.body.style.opacity = '1';
    document.body.style.pointerEvents = 'auto';
    
    const modal = document.createElement('div');
    modal.id = 'password-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        backdrop-filter: blur(4px);
    `;
    
    const isCreate = mode === 'create';
    
    modal.innerHTML = `
        <div style="
            background: #fff;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            border: 4px solid #000;
            box-shadow: 8px 8px 0 #000;
            font-family: 'Courier New', monospace;
        ">
            <h2 style="
                margin: 0 0 10px 0;
                font-size: 22px;
                font-weight: 900;
                text-transform: uppercase;
                color: #000;
                border-bottom: 3px solid #000;
                padding-bottom: 10px;
            ">
                <i class="fa-solid fa-lock" style="color: #25d366;"></i>
                ${isCreate ? 'Set Password' : 'Unlock Keys'}
            </h2>
            
            <p style="
                color: #333;
                margin: 15px 0;
                font-size: 14px;
                line-height: 1.6;
                font-weight: bold;
            ">
                ${isCreate 
                    ? '<i class="fa-solid fa-lock"></i> Create a password to secure your encryption keys. Required on all devices!'
                    :  '<i class="fa-solid fa-unlock"></i> Enter your password to unlock your encryption keys.'}
            </p>
            
            <input 
                type="password" 
                id="encryption-password" 
                placeholder="Password" 
                style="
                    width: 100%;
                    padding: 12px;
                    margin: 10px 0;
                    border: 3px solid #000;
                    background: #fff;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    font-weight: bold;
                    box-shadow: 4px 4px 0 #000;
                    box-sizing: border-box;
                "
            >
            
            ${isCreate ? `
                <input 
                    type="password" 
                    id="encryption-password-confirm" 
                    placeholder="Confirm Password" 
                    style="
                        width: 100%;
                        padding: 12px;
                        margin: 10px 0;
                        border: 3px solid #000;
                        background: #fff;
                        font-family: 'Courier New', monospace;
                        font-size: 14px;
                        font-weight: bold;
                        box-shadow: 4px 4px 0 #000;
                        box-sizing: border-box;
                    "
                >
            ` : ''}
            
            <div 
                id="password-error" 
                style="
                    color: #dc3545;
                    margin: 10px 0;
                    min-height: 20px;
                    font-weight: bold;
                    font-size: 13px;
                    padding: 8px;
                    background: #ffe0e0;
                    border: 3px solid #dc3545;
                    box-shadow: 3px 3px 0 #000;
                    display: none;
                "
            ></div>
            
            <button 
                id="password-submit" 
                style="
                    width: 100%;
                    padding: 14px;
                    background: #25d366;
                    color: #fff;
                    border: 3px solid #000;
                    box-shadow: 4px 4px 0 #000;
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    font-size: 15px;
                    cursor: pointer;
                    text-transform: uppercase;
                    transition: all 0.1s;
                    margin-top: 10px;
                "
            >
                ${isCreate ? '<i class="fa-solid fa-key"></i> Create Keys' : '<i class="fa-solid fa-lock-open"></i> Unlock'}
            </button>
            
            ${!isCreate ? `
                <button 
                    id="reset-keys-btn" 
                    style="
                        width: 100%;
                        padding: 14px;
                        background: #dc3545;
                        color: #fff;
                        border: 3px solid #000;
                        box-shadow: 4px 4px 0 #000;
                        font-family: 'Courier New', monospace;
                        font-weight: bold;
                        font-size: 14px;
                        cursor: pointer;
                        text-transform: uppercase;
                        transition: all 0.1s;
                        margin-top: 12px;
                    "
                >
                    <i class="fa-solid fa-recycle"></i>
                     Forgot Password? Reset
                </button>
            ` : ''}
            
            <p style="
                color: #666;
                font-size: 12px;
                margin: 15px 0 0 0;
                padding: 10px;
                background: #f5f5f0;
                border: 3px solid #000;
                box-shadow: 2px 2px 0 #000;
                line-height: 1.5;
                font-weight: bold;
            ">
                <i class="fa-solid fa-triangle-exclamation"></i> ${isCreate 
                    ? '<strong style="color: #dc3545;">REMEMBER THIS PASSWORD!</strong> It cannot be recovered.' 
                    : 'Forgot password? Reset keys (deletes all messages).'}
            </p>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    const passwordInput = document.getElementById('encryption-password');
    const submitButton = document.getElementById('password-submit');
    const errorDiv = document.getElementById('password-error');
    
    // Add hover effects to buttons
    submitButton.addEventListener('mouseenter', () => {
        submitButton.style.transform = 'translate(2px, 2px)';
        submitButton.style.boxShadow = '2px 2px 0 #000';
    });
    submitButton.addEventListener('mouseleave', () => {
        submitButton.style.transform = 'translate(0, 0)';
        submitButton.style.boxShadow = '4px 4px 0 #000';
    });
    submitButton.addEventListener('mousedown', () => {
        submitButton.style.transform = 'translate(4px, 4px)';
        submitButton.style.boxShadow = '0 0 0 #000';
    });
    submitButton.addEventListener('mouseup', () => {
        submitButton.style.transform = 'translate(2px, 2px)';
        submitButton.style.boxShadow = '2px 2px 0 #000';
    });
    
    // Add focus effects to inputs
    const inputs = modal.querySelectorAll('input[type="password"]');
    inputs.forEach(input => {
        input.addEventListener('focus', () => {
            input.style.background = '#fffef0';
            input.style.outline = 'none';
        });
        input.addEventListener('blur', () => {
            input.style.background = '#fff';
        });
    });
    
    // Add reset button handler if in unlock mode
    if (!isCreate) {
        const resetButton = document.getElementById('reset-keys-btn');
        
        // Add hover effects
        resetButton.addEventListener('mouseenter', () => {
            resetButton.style.transform = 'translate(2px, 2px)';
            resetButton.style.boxShadow = '2px 2px 0 #000';
        });
        resetButton.addEventListener('mouseleave', () => {
            resetButton.style.transform = 'translate(0, 0)';
            resetButton.style.boxShadow = '4px 4px 0 #000';
        });
        resetButton.addEventListener('mousedown', () => {
            resetButton.style.transform = 'translate(4px, 4px)';
            resetButton.style.boxShadow = '0 0 0 #000';
        });
        resetButton.addEventListener('mouseup', () => {
            resetButton.style.transform = 'translate(2px, 2px)';
            resetButton.style.boxShadow = '2px 2px 0 #000';
        });
        
        resetButton.onclick = async () => {
            if (!confirm('‚ö†Ô∏è WARNING! This will DELETE all your previous messages and create new encryption keys. This CANNOT be undone!\n\nAre you absolutely sure?')) {
                return;
            }
            
            if (!confirm('üö® FINAL WARNING: All your chat history will be PERMANENTLY LOST. Continue?')) {
                return;
            }
            
            resetButton.disabled = true;
            resetButton.textContent = '‚è≥ Resetting...';
            resetButton.style.background = '#999';
            resetButton.style.cursor = 'not-allowed';
            
            try {
                await fetch('/api/reset-keys/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    }
                });
                
                // Clear session storage
                sessionStorage.removeItem('encryptionPassword');
                
                modal.remove();
                showPasswordPrompt(null, 'create');
            } catch (error) {
                errorDiv.textContent = '‚ùå Failed to reset keys: ' + error.message;
                errorDiv.style.display = 'block';
                resetButton.disabled = false;
                resetButton.textContent = 'üîÑ Forgot Password? Reset';
                resetButton.style.background = '#dc3545';
                resetButton.style.cursor = 'pointer';
            }
        };
    }
    
    passwordInput.focus();
    
    const handleSubmit = async () => {
        const password = passwordInput.value;
        
        if (!password) {
            errorDiv.textContent = '‚ùå Password is required!';
            errorDiv.style.display = 'block';
            return;
        }
        
        if (isCreate) {
            const confirmInput = document.getElementById('encryption-password-confirm');
            const confirmPassword = confirmInput.value;
            
            if (password !== confirmPassword) {
                errorDiv.textContent = '‚ùå Passwords do not match!';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (password.length < 8) {
                errorDiv.textContent = '‚ùå Password must be at least 8 characters!';
                errorDiv.style.display = 'block';
                return;
            }
            
            submitButton.disabled = true;
            submitButton.textContent = '‚è≥ Creating Keys...';
            submitButton.style.background = '#999';
            submitButton.style.cursor = 'not-allowed';
            submitButton.style.transform = 'translate(0, 0)';
            submitButton.style.boxShadow = '4px 4px 0 #000';
            
            try {
                await createNewKeys(password);
                encryptionPassword = password;
                sessionStorage.setItem("encryptionPassword", password);
                modal.remove();
                encryptionReady = true;
                loadChatList();
            } catch (error) {
                errorDiv.textContent = '‚ùå Failed to create keys: ' + error.message;
                errorDiv.style.display = 'block';
                submitButton.disabled = false;
                submitButton.textContent = '‚ú® Create Keys';
                submitButton.style.background = '#25d366';
                submitButton.style.cursor = 'pointer';
            }
        } else {
            submitButton.disabled = true;
            submitButton.textContent = '‚è≥ Unlocking...';
            submitButton.style.background = '#999';
            submitButton.style.cursor = 'not-allowed';
            submitButton.style.transform = 'translate(0, 0)';
            submitButton.style.boxShadow = '4px 4px 0 #000';
            
            try {
                await unlockKeysWithPassword(serverKeys, password);
                encryptionPassword = password;
                sessionStorage.setItem("encryptionPassword", password);
                modal.remove();
                encryptionReady = true;
                loadChatList();
            } catch (error) {
                errorDiv.textContent = '‚ùå ' + error.message;
                errorDiv.style.display = 'block';
                submitButton.disabled = false;
                submitButton.textContent = 'üîì Unlock';
                submitButton.style.background = '#25d366';
                submitButton.style.cursor = 'pointer';
            }
        }
    };
    
    submitButton.onclick = handleSubmit;
    passwordInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            if (isCreate) {
                if (document.activeElement === passwordInput) {
                    document.getElementById('encryption-password-confirm').focus();
                } else {
                    handleSubmit();
                }
            } else {
                handleSubmit();
            }
        }
    });
    
    if (isCreate) {
        const confirmInput = document.getElementById('encryption-password-confirm');
        confirmInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSubmit();
        });
    }
}

        // Create new keys and encrypt with password
        async function createNewKeys(password) {
            // Generate new ECDH key pair
            myKeyPair = await crypto.subtle.generateKey(
                { name: 'ECDH', namedCurve: 'P-256' },
                true,
                ['deriveKey']
            );
            
            // Export keys
            const privateKeyJwk = await crypto.subtle.exportKey('jwk', myKeyPair.privateKey);
            const publicKeyJwk = await crypto.subtle.exportKey('jwk', myKeyPair.publicKey);
            myPublicKeyExported = JSON.stringify(publicKeyJwk);
            
            // Encrypt private key with password
            const encryptedData = await encryptPrivateKeyWithPassword(privateKeyJwk, password);
            
            // Send to server
            const response = await fetch('/api/register-public-key/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    public_key: myPublicKeyExported,
                    encrypted_private_key: encryptedData.encryptedPrivateKey,
                    salt: encryptedData.salt + ':' + encryptedData.iv // Store IV with salt
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to register keys on server');
            }
            
            console.log('Created and registered new encryption keys');
        }

        // Unlock keys with password
        async function unlockKeysWithPassword(serverKeys, password) {
            // Parse salt and IV
            const [salt, iv] = serverKeys.salt.split(':');
            
            const encryptedData = {
                encryptedPrivateKey: serverKeys.encrypted_private_key,
                salt: salt,
                iv: iv
            };
            
            // Decrypt private key
            const privateKeyJwk = await decryptPrivateKeyWithPassword(encryptedData, password);
            
            // Import keys
            myKeyPair = {
                privateKey: await crypto.subtle.importKey(
                    'jwk',
                    privateKeyJwk,
                    { name: 'ECDH', namedCurve: 'P-256' },
                    true,
                    ['deriveKey']
                ),
                publicKey: await crypto.subtle.importKey(
                    'jwk',
                    JSON.parse(serverKeys.public_key),
                    { name: 'ECDH', namedCurve: 'P-256' },
                    true,
                    []
                )
            };
            
            myPublicKeyExported = serverKeys.public_key;
            console.log('Unlocked encryption keys from server');
        }

        // Wait for encryption to be ready before allowing actions
        async function ensureEncryptionReady() {
            if (encryptionReady) return true;
            
            // Wait for up to 10 seconds
            for (let i = 0; i < 100; i++) {
                await new Promise(resolve => setTimeout(resolve, 100));
                if (encryptionReady) return true;
            }
            
            alert('Encryption setup is taking too long. Please refresh the page.');
            return false;
        }

        // Derive shared key for private chat using ECDH
        async function deriveSharedKey(partnerPublicKeyJwk) {
            const partnerPublicKey = await crypto.subtle.importKey(
                'jwk',
                JSON.parse(partnerPublicKeyJwk),
                { name: 'ECDH', namedCurve: 'P-256' },
                false,
                []
            );
            
            return await crypto.subtle.deriveKey(
                { name: 'ECDH', public: partnerPublicKey },
                myKeyPair.privateKey,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        // Generate AES key for group chat
        async function generateAESKey() {
            return await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        // Encrypt AES key for a user (for group chats)
        async function encryptKeyForUser(aesKey, userPublicKeyJwk) {
            const aesKeyRaw = await crypto.subtle.exportKey('raw', aesKey);
            
            const userPublicKey = await crypto.subtle.importKey(
                'jwk',
                JSON.parse(userPublicKeyJwk),
                { name: 'ECDH', namedCurve: 'P-256' },
                false,
                []
            );
            
            const kek = await crypto.subtle.deriveKey(
                { name: 'ECDH', public: userPublicKey },
                myKeyPair.privateKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['wrapKey']
            );
            
            const wrappedKey = await crypto.subtle.wrapKey(
                'raw',
                aesKey,
                kek,
                { name: 'AES-GCM', iv: new Uint8Array(12) }
            );
            return arrayBufferToBase64(wrappedKey);
        }

        // Decrypt AES key (for group chats)
        async function decryptKeyForUser(encryptedKeyBase64, creatorPublicKeyJwk) {
            const encryptedKey = base64ToArrayBuffer(encryptedKeyBase64);
            
            const creatorPublicKey = await crypto.subtle.importKey(
                'jwk',
                JSON.parse(creatorPublicKeyJwk),
                { name: 'ECDH', namedCurve: 'P-256' },
                false,
                []
            );
            
            const kek = await crypto.subtle.deriveKey(
                { name: 'ECDH', public: creatorPublicKey },
                myKeyPair.privateKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['unwrapKey']
            );
            
            return await crypto.subtle.unwrapKey(
                'raw',
                encryptedKey,
                kek,
                { name: 'AES-GCM', iv: new Uint8Array(12) },
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        // ========== MESSAGE ENCRYPTION/DECRYPTION ==========

        async function encryptMessage(key, message) {
            const enc = new TextEncoder();
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const ciphertext = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                enc.encode(message)
            );
            return {
                ciphertext: arrayBufferToBase64(ciphertext),
                iv: arrayBufferToBase64(iv)
            };
        }

        async function decryptMessage(key, ciphertextBase64, ivBase64) {
            const dec = new TextDecoder();
            const ciphertext = base64ToArrayBuffer(ciphertextBase64);
            const iv = base64ToArrayBuffer(ivBase64);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                ciphertext
            );
            return dec.decode(decrypted);
        }

        // ========== HELPER FUNCTIONS ==========

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            if (!base64) {
                console.warn('base64ToArrayBuffer: Input string is empty or undefined');
                return new ArrayBuffer(0);
            }
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        const csrftoken = getCookie('csrftoken');

        // ========== CHAT INTERFACE FUNCTIONS ==========

        // Search Users Live
        document.getElementById('search-box').addEventListener('keyup', function() {
            const q = this.value.trim();
            if (q.length === 0) {
                document.getElementById('search-results').innerHTML = '';
                return;
            }
            fetch(`/api/search-users/?q=${q}`)
                .then(res => res.json())
                .then(data => {
                    let html = '';
                    data.users.forEach(u => {
                        html += `<div class="user-item" onclick="startChat(${u.id})">${u.username}</div>`;
                    });
                    document.getElementById('search-results').innerHTML = html;
                });
        });

        // Start Chat (private)
        async function startChat(userId) {
            if (!await ensureEncryptionReady()) return;
            
            try {
                const res = await fetch(`/api/start-chat/${userId}/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({ my_public_key: myPublicKeyExported })
                });
                const data = await res.json();
                
                if (data.error) {
                    alert(data.error);
                    return;
                }
                
                loadChatList();
                openChat(data.chat_id);
            } catch (error) {
                console.error('Error starting chat:', error);
                alert('Failed to start chat');
            }
        }

        // Load All Chats
        function loadChatList() {
            fetch('/api/my-chats/')
                .then(res => res.json())
                .then(data => {
                    let html = '';
                    data.chats.forEach(c => {
                        const icon = c.is_group
                            ? '<i class="fa-solid fa-layer-group"></i>'
                            : '<i class="fa-solid fa-comments"></i>'
                        html += `<div class="chat-item" onclick="openChat(${c.chat_id})">
                                    ${icon}
                                    ${c.name}
                                </div>`;
                    });
                    document.getElementById('chat-list').innerHTML = html;
                });
        }

        // Open a Chat
        async function openChat(chatId) {
            if (!await ensureEncryptionReady()) return;
            
            try {
                currentChatId = chatId;
                const res = await fetch(`/api/messages/${chatId}/`);
                const data = await res.json();
                
                if (data.error) {
                    alert(data.error);
                    return;
                }

                 console.log('Chat data:', {
                    is_group: data.is_group,
                    has_encrypted_key: !!data.encrypted_chat_key,
                    has_creator_public_key: !!data.creator_public_key,
                    has_partner_public_key: !!data.partner_public_key
                });
                
                // Derive or decrypt the chat key
                if (data.is_group) {
                    chatKey = await decryptKeyForUser(data.encrypted_chat_key, data.creator_public_key);
                } else {
                    chatKey = await deriveSharedKey(data.partner_public_key);
                }
                
                // Load previous messages
                let html = '';
                for (const m of data.messages) {
                    if (m.iv) {
                        try {
                            const decrypted = await decryptMessage(chatKey, m.content, m.iv);
                            html += `<p><b>${m.sender}:</b> ${decrypted}</p>`;
                        } catch (e) {
                            console.error('Decryption error:', e);
                            html += `<p><b>${m.sender}:</b> [Decryption failed]</p>`;
                        }
                    } else {
                        html += `<p><b>${m.sender}:</b> ${m.content}</p>`;
                    }
                }
                document.getElementById('chat-log').innerHTML = html;
                
                // Enable input
                document.getElementById('chat-message-input').disabled = false;
                document.getElementById('chat-message-submit').disabled = false;
                
                // Close old connection
                if (chatSocket) {
                    chatSocket.close();
                }
                
                // Open websocket for this chat
                chatSocket = new WebSocket(
                    'ws://' + window.location.host + '/ws/chat/' + chatId + '/'
                );
                
                chatSocket.onmessage = async function(e) {
                    const data = JSON.parse(e.data);
                    if(data.type === "typing") {
                        const typingDiv = document.getElementById("typing-indicator");
                        // dont show typing indicator for current user
                        if (data.username !== "{{request.user.username}}") {
                            //typingDiv.textContent = `${data.username}`;
                            //typingDiv.style.display = 'block';
                            const usernameSpan = typingDiv.querySelector('.typing-username');
                            if (usernameSpan) {
                                usernameSpan.textContent = `${data.username} is typing`;
                            }
                            typingDiv.style.display = 'flex';
                            if (window.typingIndicatorTimeout) {
                                clearTimeout(window.typingIndicatorTimeout);
                            }
                            // hide indicator based on the TYPING_TIMER_LENGTH
                            window.typingIndicatorTimeout = setTimeout(() => {
                                typingDiv.style.display = 'none';
                            }, TYPING_TIMER_LENGTH);
                        }
                        return;
                    }
                    try {
                        const decrypted = await decryptMessage(chatKey, data.message, data.iv);
                        document.getElementById('chat-log').innerHTML +=
                            `<p><b>${data.username}:</b> ${decrypted}</p>`;
                    } catch (error) {
                        console.error('Decryption error:', error);
                    }
                };
            } catch (error) {
                console.error('Error opening chat:', error);
                alert('Failed to open chat');
            }
        }

        // Send Message
        document.getElementById('chat-message-submit').onclick = async function() {
            const input = document.getElementById('chat-message-input');
            if (!input.value.trim()) return;
            
            try {
                // clear typing timeout
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }
                const { ciphertext, iv } = await encryptMessage(chatKey, input.value);
                
                chatSocket.send(JSON.stringify({
                    message: ciphertext,
                    iv: iv
                }));
                
                input.value = '';
            } catch (error) {
                console.error('Error sending message:', error);
                alert('Failed to send message');
            }
        };

        // ========== GROUP CHAT FUNCTIONS ==========

        let selectedGroupUsers = [];
        let userIdToName = {};

        // Search users for group chat
        document.getElementById('group-search-box').addEventListener('keyup', function() {
            const q = this.value.trim();
            const resultsDiv = document.getElementById('group-search-results');
            
            if (q.length === 0) {
                resultsDiv.innerHTML = '';
                return;
            }
            
            fetch(`/api/search-users/?q=${q}`)
                .then(res => res.json())
                .then(data => {
                    let html = '';
                    data.users.forEach(u => {
                        userIdToName[u.id] = u.username;
                        if (u.id !== currentUserId && !selectedGroupUsers.includes(u.id)) {
                            html += `<div class="user-item" onclick="addGroupUser(${u.id}, '${u.username}')">
                                        ${u.username}
                                    </div>`;
                        }
                    });
                    resultsDiv.innerHTML = html;
                });
        });

        // Add user to selected list
        function addGroupUser(id, username) {
            selectedGroupUsers.push(id);
            userIdToName[id] = username;
            renderSelectedUsers();
            document.getElementById('group-search-results').innerHTML = '';
            document.getElementById('group-search-box').value = '';
        }

        // Remove user from selected list
        function removeGroupUser(id) {
            selectedGroupUsers = selectedGroupUsers.filter(uid => uid !== id);
            renderSelectedUsers();
        }

        // Render selected users
        function renderSelectedUsers() {
            const div = document.getElementById('group-selected-users');
            let html = '';
            selectedGroupUsers.forEach(id => {
                html += `<span onclick="removeGroupUser(${id})">
                            ${userIdToName[id] || 'User'} &times;
                        </span>`;
            });
            div.innerHTML = html;
        }

        // Create group
        document.getElementById('create-group-btn').onclick = async function() {
            if (!await ensureEncryptionReady()) return;
            
            const groupName = document.getElementById('group-name').value.trim();
            if (!groupName) return alert('Enter a group name');
            if (selectedGroupUsers.length === 0) return alert('Select at least one user');
            
            try {
                // Generate group AES key
                const groupKey = await generateAESKey();
                
                // Get public keys for all members (including current user)
                const allMemberIds = [currentUserId, ...selectedGroupUsers];
                const res = await fetch(`/api/get-users-public-keys/?user_ids=${allMemberIds.join(',')}`);
                const { keys } = await res.json();
                
                // Encrypt group key for each member
                const encryptedKeys = {};
                for (const userId of allMemberIds) {
                    const userPublicKey = keys[String(userId)];
                    if (!userPublicKey) {
                        alert(`User ${userIdToName[userId] || userId} hasn't set up encryption yet`);
                        return;
                    }
                    encryptedKeys[String(userId)] = await encryptKeyForUser(groupKey, userPublicKey);
                    //const wrappedKey = await encryptKeyForUser(groupKey, userPublicKey);
                    //encryptedKeys[String(userId)] = arrayBufferToBase64(wrappedKey);
                }
                
                // Create group on server
                const createRes = await fetch('/api/create-group/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        name: groupName,
                        members: selectedGroupUsers,
                        encrypted_keys: encryptedKeys
                    })
                });
                
                const createData = await createRes.json();
                
                if (createData.chat_id) {
                    loadChatList();
                    openChat(createData.chat_id);
                    document.getElementById('group-name').value = '';
                    selectedGroupUsers = [];
                    renderSelectedUsers();
                } else if (createData.error) {
                    alert(createData.error);
                }
            } catch (error) {
                console.error('Error creating group:', error);
                alert('Failed to create group');
            }
        };

        // Initialize encryption when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initEncryption();
            loadChatList();
        });
    </script>
</body>
</html>